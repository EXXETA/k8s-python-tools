#
# Copyright (c) 2019 EXXETA AG and others.
#
# This file is part of k8s-python-tools
# (see https://github.com/EXXETA/k8s-python-tools).
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import numpy
from kubernetes import client, config

from lib.common import load_kube, get_sets
from lib.input import get_current_input_adapter, PromptToolkitAdapter

# DO NOT EDIT this file manually, use "python codegen.py" in root folder. Use templates/def_confirm.py.j2

{% for confirm_item in entries %}{% if confirm_item.namespaced == True %}
def confirm_{{ confirm_item.name | normalize }}(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for {{ confirm_item.name }} given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for {{ confirm_item.name }} given")
    load_kube(context)
    api = client.{{ confirm_item.api }}()
    return general_confirm("{{ confirm_item.name }}",
                           lambda: {{ confirm_item.api_method }},
                           lambda i: i.metadata.name)
{% else %}
def confirm_{{ confirm_item.name | normalize }}(context):
    if context is None:
        raise SystemExit("invalid empty context for {{ confirm_item.name }} given")
    load_kube(context)
    api = client.{{ confirm_item.api }}()
    return general_confirm("{{ confirm_item.name }}",
                           lambda: {{ confirm_item.api_method }},
                           lambda i: i.metadata.name)
{% endif %}
{% endfor %}
def confirm(question) -> bool:
    print("Asking the question:", question)
    input_adapter = get_current_input_adapter()
    return input_adapter.yes_no("Please confirm", question)


# custom pick call, no usage of general confirm here
def confirm_set(context, namespace):
    load_kube(context)

    try:
        kube_sets = get_sets(context, namespace)
    except Exception as e:
        print(e)
        print("An error occured fetching sets from context",
              context, "and namespace", namespace)
        kube_sets = list()

    def set_label(option) -> str:
        output = ""
        if isinstance(option, client.models.v1_replica_set.V1ReplicaSet):
            output += "ReplicaSet | "
        if isinstance(option, client.models.v1_stateful_set.V1StatefulSet):
            output += "StatefulSet | "
        if isinstance(option, client.models.v1_daemon_set.V1DaemonSet):
            output += "DaemonSet | "
        output += option.metadata.name
        return output

    input_adapter = get_current_input_adapter()
    set_labels_c = [None] * len(kube_sets)
    set_labels = [None] * len(kube_sets)
    j = 0
    for i in kube_sets:
        label = set_label(i)
        if isinstance(input_adapter, PromptToolkitAdapter):
            set_labels_c[j] = (label, label)
        else:
            set_labels_c[j] = label
        set_labels[j] = i.metadata.name
        j += 1

    if kube_sets:
        selected_set = input_adapter.radio_list("Set", "", set_labels_c)
        if isinstance(input_adapter, PromptToolkitAdapter):
            set_ = kube_sets[set_labels_c.index((selected_set, selected_set))]
            return set_
        else:
            return kube_sets[set_labels_c.index(selected_set)]
    else:
        print("No sets found")
    raise SystemExit("No sets chosen or available")

# internal methods (used above)


def general_confirm(name, collection_lambda, collection_selector_lambda):
    response = collection_lambda()

    if response is None or response.items is None:
        raise SystemExit("no valid response received for " + name)

    if len(response.items) > 0:
        try:
            return pick_operation(response.items, collection_selector_lambda, name)
        except:
            return pick_operation(response, collection_selector_lambda, name)
    else:
        print("No", name + "s", "found!")
    raise SystemExit("No " + name + "s chosen or available")


def pick_operation(iterable, collection_selector_lambda, title):
    repl_list = list()

    input_adapter = get_current_input_adapter()

    for i in iterable:
        label = collection_selector_lambda(i)
        if isinstance(input_adapter, PromptToolkitAdapter):
            repl_list.append((label, label))
        else:
            repl_list.append(label)
    if repl_list:
        ret = input_adapter.radio_list(title + ":", "", repl_list)
        return ret


def confirm_namespace(context, show_warning=True):
    if context is None:
        raise SystemExit("null context given")
    load_kube(context)
    api_instance = client.CoreV1Api()

    def all_namespaces():
        return api_instance.list_namespace(watch=False)

    if show_warning:
        ret = api_instance.list_pod_for_all_namespaces(watch=False)
        non_empty_ns = set()
        for i in ret.items:
            non_empty_ns.add(i.metadata.namespace)

        all_ns = set()
        for j in all_namespaces().items:
            all_ns.add(j.metadata.namespace)

        print("Empty namespaces:", numpy.array(all_ns) - numpy.array(non_empty_ns))
    return general_confirm("Namespace", all_namespaces, lambda i: i.metadata.name)


def confirm_context() -> str:
    contexts, active_context = config.list_kube_config_contexts()
    if not contexts:
        print("Cannot find any context in kube-config file.")
        raise SystemExit("no context retrievable")
    contexts = [context["name"] for context in contexts]

    if len(contexts) is 1:
        print("Only one context", contexts[0], ' - Auto-Selecting.')
        return contexts[0]

    context_list = []
    input_adapter = get_current_input_adapter()
    for i in sorted(contexts):
        if isinstance(input_adapter, PromptToolkitAdapter):
            context_list.append((i, i))
        else:
            context_list.append(label)

    answer = input_adapter.radio_list("Context", "", context_list)
    return answer


def main():
    pass


if __name__ == "__main__":
    main()
