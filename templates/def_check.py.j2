#
# Copyright (c) 2019 EXXETA AG and others.
#
# This file is part of k8s-python-tools
# (see https://github.com/EXXETA/k8s-python-tools).
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
from kubernetes.client.rest import ApiException

from lib.common import load_kube, SetType
from kubernetes import client
import time
import datetime

wait_timeout_seconds = 30

# DO NOT EDIT this file manually, use "python codegen.py" in root folder. Use templates/def_check.py.j2

{% for check_item in entries %}
{% if check_item.namespaced == True %}
def wait_for_{{ check_item.name | normalize }}_is_away(context, namespace, name):
    if name is None:
        raise SystemExit("invalid empty name for {{ check_item.name }} given")
    if context is None:
        raise SystemExit("invalid empty name context given")
    if namespace is None:
        raise SystemExit("invalid empty name namespace given")
    load_kube(context)
    print("check removal of", "{{ check_item.name }}", name, "in namespace", namespace)
    api = client.{{ check_item.api }}()
    return general_away_check(namespace, "{{ check_item.name }}", name,
                              lambda: {{ check_item.api_method }})
{% else %}
def wait_for_{{ check_item.name | normalize }}_is_away(context, name):
    if name is None:
        raise SystemExit("invalid empty name for {{ check_item.name }} given")
    if context is None:
        raise SystemExit("invalid empty name context given")
    load_kube(context)
    print("check removal of", "{{ check_item.name }}", name)
    api = client.{{ check_item.api }}()
    return general_away_check(None, "{{ check_item.name }}", name,
                              lambda: {{ check_item.api_method }})
{% endif %}{% endfor %}
{% for check_item in entries %}
{% if check_item.namespaced == True %}
def wait_for_{{ check_item.name | normalize }}_is_up(context, namespace, name):
    if name is None:
        raise SystemExit("invalid empty name for {{ check_item.name }} given")
    if context is None:
        raise SystemExit("invalid empty name context given")
    if namespace is None:
        raise SystemExit("invalid empty name namespace given")
    load_kube(context)
    print("check availability of", "{{ check_item.name }}", name, "in namespace", namespace)
    api = client.{{ check_item.api }}()
    return general_up_check(namespace, "{{ check_item.name }}", name,
                            lambda: {{ check_item.api_method }})
{% else %}
def wait_for_{{ check_item.name | normalize }}_is_up(context, name):
    if name is None:
        raise SystemExit("invalid empty name for {{ check_item.name }} given")
    if context is None:
        raise SystemExit("invalid empty name context given")
    load_kube(context)
    print("check availability of", "{{ check_item.name }}", name)
    api = client.{{ check_item.api }}()
    return general_up_check(None, "{{ check_item.name }}", name,
                            lambda: {{ check_item.api_method }})
{% endif %}{% endfor %}
def wait_for_set_is_away(context, namespace, set_type, set_name):
    load_kube(context)
    print("check removal of set", set_name, "of type", set_type, "in namespace", namespace)
    api = client.AppsV1Api()
    def handle_sets():
        if set_type == SetType.replica_set:
            return api.read_namespaced_replica_set_with_http_info(set_name, namespace=namespace)
        elif set_type == SetType.stateful_set:
            return api.read_namespaced_stateful_set_with_http_info(set_name, namespace=namespace)
        elif set_type == SetType.daemon_set:
            return api.read_namespaced_daemon_set_with_http_info(set_name, namespace=namespace)
        else:
            raise SystemExit("Invalid type", set_type)

    return general_away_check(namespace, set_type, set_name, handle_sets)

# internal methods (used by methods above)


def general_away_check(namespace, object_name, name, api_query_lambda):
    return general_status_check(namespace, object_name, name, api_query_lambda, 404)


def general_up_check(namespace, object_name, name, api_query_lambda):
    return general_status_check(namespace, object_name, name, api_query_lambda, 200)


def general_status_check(namespace, object_name, name, api_query_lambda, expected_status):
    status = 0
    attempts = 0
    start_date = time.mktime(datetime.datetime.utcnow().timetuple())
    while status != expected_status:
        try:
            attempts += 1
            ret, status, _ = api_query_lambda()
        except ApiException:
            if namespace is not None:
                print("Status", expected_status,
                      "received.", object_name, name, "in namespace", namespace, "is removed")
            else:
                print("Status", expected_status, "received.", object_name, name)
            status = 404
        time.sleep(0.75)
        if time.mktime(datetime.datetime.utcnow().timetuple()) - start_date > wait_timeout_seconds:
            print(object_name, "status", expected_status,
                  "could not be checked after a timeout of", wait_timeout_seconds, "seconds and", attempts, "checks")
            return False
    return True


def main():
    pass


if __name__ == "__main__":
    main()
