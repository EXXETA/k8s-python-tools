#
# Copyright (c) 2019 EXXETA AG and others.
#
# This file is part of k8s-python-tools
# (see https://github.com/EXXETA/k8s-python-tools).
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
from kubernetes import client
from lib.common import SetType, load_kube

# DO NOT EDIT this file manually, use "python codegen.py" in root folder to generate and change file in "templates" folder
# Use templates/def_remove.py.j2

{% for removal_item in entries %}
{% if removal_item.namespaced == True %}
def remove_{{ removal_item.name | normalize }}(context, namespace, name):
    if context is None:
        raise SystemExit("invalid empty context for {{ removal_item.name }} given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for {{ removal_item.name }} given")
    if name is None:
        raise SystemExit("invalid empty name for {{ removal_item.name }} given")

    load_kube(context)
    api = client.{{ removal_item.api }}()
    ret, status, _ = {{ removal_item.api_method }}
    handle_status(ret, status, "{{ removal_item.name }}", namespace, name)
{% else %}
def remove_{{ removal_item.name | normalize }}(context, name):
    if context is None:
        raise SystemExit("invalid empty context for {{ removal_item.name }} given")
    if name is None:
        raise SystemExit("invalid empty name for {{ removal_item.name }} given")

    load_kube(context)
    api = client.{{ removal_item.api }}()
    ret, status, _ = {{ removal_item.api_method }}
    handle_status(ret, status, "{{ removal_item.name }}", None, name)
{% endif %}{% endfor %}

def remove_set(context, namespace, set_type: SetType, set_name: str):
    load_kube(context)
    api = client.AppsV1Api()
    print("remove set of type", set_type, "and name", set_name, "in namespace", namespace)

    if not isinstance(set_type, SetType):
        raise SystemExit("invalid set type", set_type, "given")

    if set_type == SetType.replica_set:
        ret, status, _ = api.delete_namespaced_replica_set_with_http_info(set_name, namespace=namespace)
    elif set_type == SetType.stateful_set:
        ret, status, _ = api.delete_namespaced_stateful_set_with_http_info(set_name, namespace=namespace)
    elif set_type == SetType.daemon_set:
        ret, status, _ = api.delete_namespaced_daemon_set_with_http_info(set_name, namespace=namespace)
    else:
        raise SystemExit("invalid type", set_type)

    handle_status(ret, status, set_type, namespace, set_name)
# internal method (used above)


def handle_status(ret, status, object_name, namespace, name):
    print("returned status code:", status)
    if status != None and status == 200:
        print("successfully removed", object_name, name, "in namespace", namespace)
        return
    else:
        print(ret)
    raise SystemExit("error killing", object_name, name, "in namespace", namespace)


def main():
    pass


if __name__ == "__main__":
    main()
