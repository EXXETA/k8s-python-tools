#
# Copyright (c) 2019 EXXETA AG and others.
#
# This file is part of k8s-python-tools
# (see https://github.com/EXXETA/k8s-python-tools).
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import numpy
from kubernetes import client, config

from lib.common import load_kube, get_sets
from lib.input import get_current_input_adapter, PromptToolkitAdapter

# DO NOT EDIT this file manually, use "python codegen.py" in root folder. Use templates/def_confirm.py.j2


def confirm_pod(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Pod given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Pod given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Pod",
                           lambda: api.list_namespaced_pod(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_deployment(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Deployment given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Deployment given")
    load_kube(context)
    api = client.ExtensionsV1beta1Api()
    return general_confirm("Deployment",
                           lambda: api.list_namespaced_deployment(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_service(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Service given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Service given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Service",
                           lambda: api.list_namespaced_service(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_replication_controller(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for ReplicationController given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for ReplicationController given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("ReplicationController",
                           lambda: api.list_namespaced_replication_controller(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_persistent_volume_claim(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for PersistentVolumeClaim given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for PersistentVolumeClaim given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("PersistentVolumeClaim",
                           lambda: api.list_namespaced_persistent_volume_claim(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_ingress(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Ingress given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Ingress given")
    load_kube(context)
    api = client.ExtensionsV1beta1Api()
    return general_confirm("Ingress",
                           lambda: api.list_namespaced_ingress(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_network_policy(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for NetworkPolicy given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for NetworkPolicy given")
    load_kube(context)
    api = client.ExtensionsV1beta1Api()
    return general_confirm("NetworkPolicy",
                           lambda: api.list_namespaced_network_policy(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_job(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Job given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Job given")
    load_kube(context)
    api = client.BatchV1Api()
    return general_confirm("Job",
                           lambda: api.list_namespaced_job(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_cron_job(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for CronJob given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for CronJob given")
    load_kube(context)
    api = client.BatchV1beta1Api()
    return general_confirm("CronJob",
                           lambda: api.list_namespaced_cron_job(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_config_map(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for ConfigMap given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for ConfigMap given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("ConfigMap",
                           lambda: api.list_namespaced_config_map(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_secret(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Secret given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Secret given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Secret",
                           lambda: api.list_namespaced_secret(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_service_account(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for ServiceAccount given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for ServiceAccount given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("ServiceAccount",
                           lambda: api.list_namespaced_service_account(namespace=namespace),
                           lambda i: i.metadata.name)


def confirm_resource_quota(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for ResourceQuota given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for ResourceQuota given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("ResourceQuota",
                           lambda: api.list_namespaced_resource_quota(namespace),
                           lambda i: i.metadata.name)


def confirm_endpoints(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Endpoints given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Endpoints given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Endpoints",
                           lambda: api.list_namespaced_endpoints(namespace),
                           lambda i: i.metadata.name)


def confirm_pod_template(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for PodTemplate given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for PodTemplate given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("PodTemplate",
                           lambda: api.list_namespaced_pod_template(namespace),
                           lambda i: i.metadata.name)


def confirm_role_binding(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for RoleBinding given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for RoleBinding given")
    load_kube(context)
    api = client.RbacAuthorizationV1Api()
    return general_confirm("RoleBinding",
                           lambda: api.list_namespaced_role_binding(namespace),
                           lambda i: i.metadata.name)


def confirm_role(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Role given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Role given")
    load_kube(context)
    api = client.RbacAuthorizationV1Api()
    return general_confirm("Role",
                           lambda: api.list_namespaced_role(namespace),
                           lambda i: i.metadata.name)


def confirm_pod_disruption_budget(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for PodDisruptionBudget given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for PodDisruptionBudget given")
    load_kube(context)
    api = client.PolicyV1beta1Api()
    return general_confirm("PodDisruptionBudget",
                           lambda: api.list_namespaced_pod_disruption_budget(namespace),
                           lambda i: i.metadata.name)


def confirm_event(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Event given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Event given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Event",
                           lambda: api.list_namespaced_event(namespace),
                           lambda i: i.metadata.name)


def confirm_lease(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for Lease given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for Lease given")
    load_kube(context)
    api = client.CoordinationV1beta1Api()
    return general_confirm("Lease",
                           lambda: api.list_namespaced_lease(namespace),
                           lambda i: i.metadata.name)


def confirm_horizontal_pod_autoscaler(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for HorizontalPodAutoscaler given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for HorizontalPodAutoscaler given")
    load_kube(context)
    api = client.AutoscalingV1Api()
    return general_confirm("HorizontalPodAutoscaler",
                           lambda: api.list_namespaced_horizontal_pod_autoscaler(namespace),
                           lambda i: i.metadata.name)


def confirm_controller_revision(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for ControllerRevision given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for ControllerRevision given")
    load_kube(context)
    api = client.AppsV1Api()
    return general_confirm("ControllerRevision",
                           lambda: api.list_namespaced_controller_revision(namespace),
                           lambda i: i.metadata.name)


def confirm_limit_range(context, namespace):
    if context is None:
        raise SystemExit("invalid empty context for LimitRange given")
    if namespace is None:
        raise SystemExit("invalid empty namespace for LimitRange given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("LimitRange",
                           lambda: api.list_namespaced_limit_range(namespace),
                           lambda i: i.metadata.name)


def confirm_cluster_role(context):
    if context is None:
        raise SystemExit("invalid empty context for ClusterRole given")
    load_kube(context)
    api = client.RbacAuthorizationV1Api()
    return general_confirm("ClusterRole",
                           lambda: api.list_cluster_role(),
                           lambda i: i.metadata.name)


def confirm_cluster_role_binding(context):
    if context is None:
        raise SystemExit("invalid empty context for ClusterRoleBinding given")
    load_kube(context)
    api = client.RbacAuthorizationV1Api()
    return general_confirm("ClusterRoleBinding",
                           lambda: api.list_cluster_role_binding(),
                           lambda i: i.metadata.name)


def confirm_pod_security_policy(context):
    if context is None:
        raise SystemExit("invalid empty context for PodSecurityPolicy given")
    load_kube(context)
    api = client.PolicyV1beta1Api()
    return general_confirm("PodSecurityPolicy",
                           lambda: api.list_pod_security_policy(),
                           lambda i: i.metadata.name)


def confirm_persistent_volume(context):
    if context is None:
        raise SystemExit("invalid empty context for PersistentVolume given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("PersistentVolume",
                           lambda: api.list_persistent_volume(),
                           lambda i: i.metadata.name)


def confirm_volume_attachment(context):
    if context is None:
        raise SystemExit("invalid empty context for VolumeAttachment given")
    load_kube(context)
    api = client.StorageV1Api()
    return general_confirm("VolumeAttachment",
                           lambda: api.list_volume_attachment(),
                           lambda i: i.metadata.name)


def confirm_storage_class(context):
    if context is None:
        raise SystemExit("invalid empty context for StorageClass given")
    load_kube(context)
    api = client.StorageV1Api()
    return general_confirm("StorageClass",
                           lambda: api.list_storage_class(),
                           lambda i: i.metadata.name)


def confirm_priority_class(context):
    if context is None:
        raise SystemExit("invalid empty context for PriorityClass given")
    load_kube(context)
    api = client.SchedulingV1beta1Api()
    return general_confirm("PriorityClass",
                           lambda: api.list_priority_class(),
                           lambda i: i.metadata.name)


def confirm_node(context):
    if context is None:
        raise SystemExit("invalid empty context for Node given")
    load_kube(context)
    api = client.CoreV1Api()
    return general_confirm("Node",
                           lambda: api.list_node(),
                           lambda i: i.metadata.name)


def confirm_custom_resource_definition(context):
    if context is None:
        raise SystemExit("invalid empty context for CustomResourceDefinition given")
    load_kube(context)
    api = client.ApiextensionsV1beta1Api()
    return general_confirm("CustomResourceDefinition",
                           lambda: api.list_custom_resource_definition(),
                           lambda i: i.metadata.name)


def confirm_certificate_signing_request(context):
    if context is None:
        raise SystemExit("invalid empty context for CertificateSigningRequest given")
    load_kube(context)
    api = client.CertificatesV1beta1Api()
    return general_confirm("CertificateSigningRequest",
                           lambda: api.list_certificate_signing_request(),
                           lambda i: i.metadata.name)


def confirm(question) -> bool:
    print("Asking the question:", question)
    input_adapter = get_current_input_adapter()
    return input_adapter.yes_no("Please confirm", question)


# custom pick call, no usage of general confirm here
def confirm_set(context, namespace):
    load_kube(context)

    try:
        kube_sets = get_sets(context, namespace)
    except Exception as e:
        print(e)
        print("An error occured fetching sets from context",
              context, "and namespace", namespace)
        kube_sets = list()

    def set_label(option) -> str:
        output = ""
        if isinstance(option, client.models.v1_replica_set.V1ReplicaSet):
            output += "ReplicaSet | "
        if isinstance(option, client.models.v1_stateful_set.V1StatefulSet):
            output += "StatefulSet | "
        if isinstance(option, client.models.v1_daemon_set.V1DaemonSet):
            output += "DaemonSet | "
        output += option.metadata.name
        return output

    input_adapter = get_current_input_adapter()
    set_labels_c = [None] * len(kube_sets)
    set_labels = [None] * len(kube_sets)
    j = 0
    for i in kube_sets:
        label = set_label(i)
        if isinstance(input_adapter, PromptToolkitAdapter):
            set_labels_c[j] = (label, label)
        else:
            set_labels_c[j] = label
        set_labels[j] = i.metadata.name
        j += 1

    if kube_sets:
        selected_set = input_adapter.radio_list("Set", "", set_labels_c)
        if isinstance(input_adapter, PromptToolkitAdapter):
            set_ = kube_sets[set_labels_c.index((selected_set, selected_set))]
            return set_
        else:
            return kube_sets[set_labels_c.index(selected_set)]
    else:
        print("No sets found")
    raise SystemExit("No sets chosen or available")

# internal methods (used above)


def general_confirm(name, collection_lambda, collection_selector_lambda):
    response = collection_lambda()

    if response is None or response.items is None:
        raise SystemExit("no valid response received for " + name)

    if len(response.items) > 0:
        try:
            return pick_operation(response.items, collection_selector_lambda, name)
        except:
            return pick_operation(response, collection_selector_lambda, name)
    else:
        print("No", name + "s", "found!")
    raise SystemExit("No " + name + "s chosen or available")


def pick_operation(iterable, collection_selector_lambda, title):
    repl_list = list()

    input_adapter = get_current_input_adapter()

    for i in iterable:
        label = collection_selector_lambda(i)
        if isinstance(input_adapter, PromptToolkitAdapter):
            repl_list.append((label, label))
        else:
            repl_list.append(label)
    if repl_list:
        ret = input_adapter.radio_list(title + ":", "", repl_list)
        return ret


def confirm_namespace(context, show_warning=True):
    if context is None:
        raise SystemExit("null context given")
    load_kube(context)
    api_instance = client.CoreV1Api()

    def all_namespaces():
        return api_instance.list_namespace(watch=False)

    if show_warning:
        ret = api_instance.list_pod_for_all_namespaces(watch=False)
        non_empty_ns = set()
        for i in ret.items:
            non_empty_ns.add(i.metadata.namespace)

        all_ns = set()
        for j in all_namespaces().items:
            all_ns.add(j.metadata.namespace)

        print("Empty namespaces:", numpy.array(all_ns) - numpy.array(non_empty_ns))
    return general_confirm("Namespace", all_namespaces, lambda i: i.metadata.name)


def confirm_context() -> str:
    contexts, active_context = config.list_kube_config_contexts()
    if not contexts:
        print("Cannot find any context in kube-config file.")
        raise SystemExit("no context retrievable")
    contexts = [context["name"] for context in contexts]

    if len(contexts) is 1:
        print("Only one context", contexts[0], ' - Auto-Selecting.')
        return contexts[0]

    context_list = []
    input_adapter = get_current_input_adapter()
    for i in sorted(contexts):
        if isinstance(input_adapter, PromptToolkitAdapter):
            context_list.append((i, i))
        else:
            context_list.append(label)

    answer = input_adapter.radio_list("Context", "", context_list)
    return answer


def main():
    pass


if __name__ == "__main__":
    main()